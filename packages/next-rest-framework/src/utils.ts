import http from 'http';
import { OPEN_API_VERSION, ValidMethod } from './constants';
import { NextRestFrameworkConfig } from './types';
import { readFileSync } from 'fs';
import { join } from 'path';
import { generatePaths } from './generate-paths';
import { z } from 'zod';
import * as yup from 'yup';
import { OpenAPIV3_1 } from 'openapi-types';
import chalk from 'chalk';
import merge from 'lodash.merge';
import { Modify } from './utility-types';
import yaml from 'js-yaml';
import { NextApiRequest, NextApiResponse } from 'next';
import isEqualWith from 'lodash.isequalwith';

export const getDefaultConfig = ({
  config
}: {
  config?: NextRestFrameworkConfig;
} = {}): Modify<
  NextRestFrameworkConfig,
  {
    openApiSpec: OpenAPIV3_1.Document;
  }
> => ({
  openApiSpec: {
    openapi: OPEN_API_VERSION,
    info: {
      title: 'Next REST Framework',
      description:
        'This is an autogenerated OpenAPI spec by Next REST Framework.',
      // Ignore: We don't want to use promises here to avoid making this an async function.
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      version: require('../package.json').version
    },
    components: {}
  },
  openApiJsonPath: '/api/openapi.json',
  openApiYamlPath: '/api/openapi.yaml',
  swaggerUiPath: '/api',
  exposeOpenApiSpec: true,
  errorHandler: ({ error }) => {
    if (process.env.NODE_ENV !== 'production') {
      console.error(
        chalk.red(`Next REST Framework encountered an error:
${error}`)
      );
    } else {
      console.error(
        chalk.red(
          'Next REST Framework encountered an error - suppressed in production mode.'
        )
      );
    }
  },
  suppressInfo: false
});

export const logInitInfo = ({
  config
}: {
  config: NextRestFrameworkConfig;
}) => {
  const configsEqual = isEqualWith(
    global.nextRestFrameworkConfig,
    config,
    (val1, val2) => {
      if (typeof val1 === 'function' && typeof val2 === 'function') {
        return val1.toString() === val2.toString();
      }
    }
  );

  if (!global.nextRestFrameworkConfig) {
    global.nextRestFrameworkConfig = config;
    console.info(chalk.green('Next REST Framework initialized! ðŸš€'));
  } else if (!configsEqual) {
    console.info(
      chalk.green('Next REST Framework config changed, re-initializing!')
    );

    global.nextRestFrameworkConfig = config;
    global.reservedPathsLogged = false;
  }
};

export const logReservedPaths = ({
  config,
  headers
}: {
  config: NextRestFrameworkConfig;
  headers: http.IncomingHttpHeaders;
}) => {
  const proto = headers['x-forwarded-proto'] ?? 'http';
  const host = headers.host;
  const baseUrl = `${proto}://${host}`;

  if (config.exposeOpenApiSpec) {
    console.info(
      chalk.yellowBright(`Swagger UI: ${baseUrl}${config.swaggerUiPath}
OpenAPI JSON: ${baseUrl}${config.openApiJsonPath}
OpenAPI YAML: ${baseUrl}${config.openApiYamlPath}`)
    );
  } else {
    console.info(
      chalk.yellowBright(
        `OpenAPI spec is not exposed. To expose it, set ${chalk.bold(
          'exposeOpenApiSpec'
        )} to ${chalk.bold('true')} in the Next REST Framework config.`
      )
    );
  }

  global.reservedPathsLogged = true;
};

export const warnAboutReservedPath = ({
  path,
  name,
  configName
}: {
  path?: string;
  name: string;
  configName: 'openApiJsonPath' | 'openApiYamlPath' | 'swaggerUiPath';
}) => {
  console.warn(
    chalk.yellowBright(
      `Warning: ${chalk.bold(
        path
      )} is reserved for ${name}. Update ${chalk.bold(
        configName
      )} in your Next REST Framework config to use this path for other purposes.`
    )
  );

  switch (configName) {
    case 'openApiJsonPath': {
      global.reservedOpenApiJsonPathWarningLogged = true;
      break;
    }
    case 'openApiYamlPath': {
      global.reservedOpenApiYamlPathWarningLogged = true;
      break;
    }
    case 'swaggerUiPath': {
      global.reservedSwaggerUiPathWarningLogged = true;
      break;
    }
  }
};

export const handleReservedPaths = async ({
  req: { url, headers },
  res,
  config
}: {
  req: NextApiRequest;
  res: NextApiResponse;
  config: NextRestFrameworkConfig;
}) => {
  const { openApiJsonPath, openApiYamlPath, swaggerUiPath } = config;
  const spec = await getOpenApiSpecWithPaths({ config });

  if (url === openApiJsonPath) {
    res.status(200).json(spec);
    return true;
  }

  if (url === openApiYamlPath) {
    res.setHeader('Content-Type', 'text/plain');
    res.status(200).send(yaml.dump(spec));
    return true;
  }

  if (url === swaggerUiPath) {
    const html = getHTMLForSwaggerUI({ headers });
    res.setHeader('Content-Type', 'text/html');
    res.status(200).send(html);
    return true;
  }

  return false;
};

export const getHTMLForSwaggerUI = ({
  headers
}: {
  headers: http.IncomingHttpHeaders;
}) => {
  const proto = headers['x-forwarded-proto'] ?? 'http';
  const host = headers.host;
  const url = `${proto}://${host}/api/openapi.yaml`;

  const css = readFileSync(
    join(
      process.cwd(),
      'node_modules/next-rest-framework/dist/swagger-ui/swagger-ui.css'
    )
  );

  const swaggerUiBundle = readFileSync(
    join(
      process.cwd(),
      'node_modules/next-rest-framework/dist/swagger-ui/swagger-ui-bundle.js'
    )
  );

  const swaggerUiStandalonePreset = readFileSync(
    join(
      process.cwd(),
      'node_modules/next-rest-framework/dist/swagger-ui/swagger-ui-standalone-preset.js'
    )
  );

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="SwaggerUI"
  />
  <title>Next REST Framework | SwaggerUI</title>
  <style>${css}</style>
</head>
<body>
<div id="swagger-ui"></div>
<script>${swaggerUiBundle}</script>
<script>${swaggerUiStandalonePreset}</script>
<script>
  window.onload = () => {
    window.ui = SwaggerUIBundle({
        url: '${url}',
        dom_id: '#swagger-ui',
        presets: [
          SwaggerUIBundle.presets.apis,
          SwaggerUIStandalonePreset
        ],
        layout: "StandaloneLayout",
    });
  };
</script>
</body>
</html>`;
};

export const isValidMethod = (x: unknown): x is ValidMethod =>
  Object.values(ValidMethod).includes(x as ValidMethod);

export const getOpenApiSpecWithPaths = async <GlobalMiddlewareResponse>({
  config
}: {
  config: NextRestFrameworkConfig<GlobalMiddlewareResponse>;
}) => {
  const paths = await generatePaths({ config });

  return {
    ...config.openApiSpec,
    openapi: OPEN_API_VERSION,
    paths: merge(config.openApiSpec?.paths, paths)
  };
};

export const isZodSchema = (obj: unknown): obj is z.ZodAny => {
  return !!obj && typeof obj === 'object' && '_def' in obj;
};

export const isYupSchema = (obj: unknown): obj is yup.AnySchema => {
  return !!obj && obj.constructor.name === 'ObjectSchema';
};

export const isYupValidationError = (e: unknown): e is yup.ValidationError => {
  return e instanceof Error && e.name === 'ValidationError';
};
