import { NextRestFramework } from '../../src';
import {
  DEFAULT_CONFIG,
  getConfig,
  getHTMLForSwaggerUI,
  validateSchema
} from '../../src/utils';
import { DEFAULT_ERRORS, VERSION, ValidMethod } from '../../src/constants';
import chalk from 'chalk';
import { createNextRestFrameworkMocks, resetCustomGlobals } from '../utils';
import { z } from 'zod';
import { NextResponse } from 'next/server';
import { type NextRestFrameworkConfig } from '../../src/types';

jest.mock('fs', () => ({
  readdirSync: () => [],
  readFileSync: () => '',
  writeFileSync: () => {}
}));

jest.mock('next/headers', () => ({
  cookies: () => ({
    get: () => {}
  })
}));

const config = { appDirPath: 'app' } as const;

beforeEach(() => {
  resetCustomGlobals();
});

it('uses the default config by default', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET,
    path: '/api'
  });

  expect(global.nextRestFrameworkConfig).toEqual(undefined);
  await NextRestFramework().defineCatchAllRoute()(req, context);
  expect(global.nextRestFrameworkConfig).toEqual(DEFAULT_CONFIG);
});

it('sets the global config', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET,
    path: '/api'
  });

  const customConfig: NextRestFrameworkConfig = {
    ...config,
    openApiSpecOverrides: {
      info: {
        title: 'Some Title',
        version: '1.2.3'
      },
      paths: {}
    },
    openApiJsonPath: '/foo/bar',
    openApiYamlPath: '/bar/baz',
    swaggerUiPath: '/baz/qux',
    exposeOpenApiSpec: false
  };

  await NextRestFramework(customConfig).defineCatchAllRoute()(req, context);
  expect(global.nextRestFrameworkConfig).toEqual(getConfig(customConfig));
});

it('logs init, reserved paths and config changed info', async () => {
  console.info = jest.fn();

  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET,
    path: '/api/openapi.yaml'
  });

  await NextRestFramework(config).defineCatchAllRoute()(req, context);

  expect(console.info).toHaveBeenNthCalledWith(
    1,
    chalk.green('Next REST Framework initialized! ðŸš€')
  );

  expect(console.info).toHaveBeenNthCalledWith(
    2,
    chalk.yellowBright(`Swagger UI: http://localhost:3000/api
OpenAPI JSON: http://localhost:3000/api/openapi.json
OpenAPI YAML: http://localhost:3000/api/openapi.yaml`)
  );

  expect(console.info).toHaveBeenNthCalledWith(
    3,
    chalk.yellowBright('No API spec found, generating openapi.json')
  );

  expect(console.info).toHaveBeenNthCalledWith(
    4,
    chalk.green('API spec generated successfully!')
  );

  expect(console.info).toHaveBeenCalledTimes(4);

  await NextRestFramework({
    ...config,
    swaggerUiPath: '/api/foo/bar',
    openApiJsonPath: '/api/bar/baz',
    openApiYamlPath: '/api/baz/qux'
  }).defineCatchAllRoute()(req, context);

  expect(console.info).toHaveBeenNthCalledWith(
    5,
    chalk.green('Next REST Framework config changed, re-initializing!')
  );

  expect(console.info).toHaveBeenNthCalledWith(
    6,
    chalk.yellowBright(`Swagger UI: http://localhost:3000/api/foo/bar
OpenAPI JSON: http://localhost:3000/api/bar/baz
OpenAPI YAML: http://localhost:3000/api/baz/qux`)
  );

  expect(console.info).toHaveBeenCalledTimes(6);

  await NextRestFramework({
    ...config,
    exposeOpenApiSpec: false
  }).defineCatchAllRoute()(req, context);

  expect(console.info).toHaveBeenNthCalledWith(
    7,
    chalk.green('Next REST Framework config changed, re-initializing!')
  );

  expect(console.info).toHaveBeenNthCalledWith(
    8,
    chalk.yellowBright(
      `OpenAPI spec is not exposed. To expose it, set ${chalk.bold(
        'exposeOpenApiSpec'
      )} to ${chalk.bold('true')} in the Next REST Framework config.`
    )
  );

  expect(console.info).toHaveBeenCalledTimes(8);
});

it('returns OpenAPI YAML spec', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET,
    path: '/api/openapi.yaml'
  });

  const res = await NextRestFramework(config).defineCatchAllRoute()(
    req,
    context
  );

  const text = await res?.text();

  const yaml = `openapi: 3.0.1
info:
  title: Next REST Framework
  description: This is an autogenerated OpenAPI spec by Next REST Framework.
  version: ${VERSION}
components: {}
paths: {}
`;

  expect(text).toEqual(yaml);
});

it('returns OpenAPI JSON spec', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET,
    path: '/api/openapi.json'
  });

  const res = await NextRestFramework(config).defineCatchAllRoute()(
    req,
    context
  );

  const data = await res?.json();

  const json = {
    openapi: '3.0.1',
    info: {
      title: 'Next REST Framework',
      description:
        'This is an autogenerated OpenAPI spec by Next REST Framework.',
      version: VERSION
    },
    components: {},
    paths: {}
  };

  expect(data).toEqual(json);
});

it('returns Swagger UI', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET,
    path: '/api'
  });

  const _config = {
    ...config,
    swaggerUiConfig: {
      title: 'foo',
      description: 'bar',
      faviconHref: 'baz.ico',
      logoHref: 'qux.jpeg'
    }
  };

  const res = await NextRestFramework(_config).defineCatchAllRoute()(
    req,
    context
  );

  const text = await res?.text();

  const html = getHTMLForSwaggerUI({
    config: getConfig(_config),
    baseUrl: 'http://localhost:3000'
  });

  expect(text).toEqual(html);
  expect(text).toContain('foo');
  expect(text).toContain('bar');
  expect(text).toContain('baz.ico');
  expect(text).toContain('qux.jpeg');
});

it.each(Object.values(ValidMethod))(
  'works with HTTP method: %p',
  async (method) => {
    const { req, context } = createNextRestFrameworkMocks({
      method
    });

    const output = [
      {
        status: 200,
        contentType: 'application/json',
        schema: z.array(z.string())
      }
    ];

    const data = ['All good!'];
    const handler = () => NextResponse.json(data);

    const res = await NextRestFramework(config).defineRoute({
      GET: {
        output,
        handler
      },
      PUT: {
        output,
        handler
      },
      POST: {
        output,
        handler
      },
      DELETE: {
        output,
        handler
      },
      OPTIONS: {
        output,
        handler
      },
      HEAD: {
        output,
        handler
      },
      PATCH: {
        output,
        handler
      }
    })(req, context);

    const json = await res?.json();
    expect(json).toEqual(data);
  }
);

it('returns error for valid methods with no handlers', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.POST
  });

  const res = await NextRestFramework(config).defineRoute({
    GET: {
      output: [],
      handler: () => {}
    }
  })(req, context);

  const json = await res?.json();

  expect(res?.status).toEqual(405);
  expect(res?.headers.get('Allow')).toEqual('GET');

  expect(json).toEqual({
    message: DEFAULT_ERRORS.methodNotAllowed
  });
});

it('works with a valid catch-all-handler', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.POST
  });

  const res = await NextRestFramework(config).defineCatchAllRoute({
    POST: {
      output: [
        {
          status: 200,
          contentType: 'application/json',
          schema: z.object({ message: z.string() })
        }
      ],
      handler: () => {
        return NextResponse.json({ message: 'All good!' }, { status: 200 });
      }
    }
  })(req, context);

  const json = await res?.json();
  expect(res?.status).toEqual(200);

  expect(json).toEqual({
    message: 'All good!'
  });
});

it('returns 404 from a catch-all-handler instead of 405', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET
  });

  const res = await NextRestFramework(config).defineCatchAllRoute({
    POST: {
      output: [],
      handler: () => {}
    }
  })(req, context);

  const json = await res?.json();
  expect(res?.status).toEqual(404);

  expect(json).toEqual({
    message: DEFAULT_ERRORS.notFound
  });
});

it('returns error for invalid request body', async () => {
  const body = {
    foo: 'bar'
  };

  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.POST,
    body,
    headers: {
      'content-type': 'application/json'
    }
  });

  const schema = z.object({
    foo: z.number()
  });

  const res = await NextRestFramework(config).defineRoute({
    POST: {
      input: {
        contentType: 'application/json',
        body: schema
      },
      output: [],
      handler: () => {}
    }
  })(req, context);

  const json = await res?.json();
  expect(res?.status).toEqual(400);

  const { errors } = await validateSchema({ schema, obj: body });

  expect(json).toEqual({
    message: 'Invalid request body.',
    errors
  });
});

it('returns error for invalid query parameters', async () => {
  const query = {
    foo: 'bar'
  };

  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.POST,
    query,
    headers: {
      'content-type': 'application/json'
    }
  });

  const schema = z.object({
    foo: z.number()
  });

  const res = await NextRestFramework(config).defineRoute({
    POST: {
      input: {
        contentType: 'application/json',
        query: schema
      },
      output: [],
      handler: () => {}
    }
    // @ts-expect-error: Intentionally invalid.
  })(req, context);

  const json = await res?.json();
  expect(res?.status).toEqual(400);

  const { errors } = await validateSchema({ schema, obj: query });

  expect(json).toEqual({
    message: 'Invalid query parameters.',
    errors
  });
});

it('returns error for invalid content-type', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.POST,
    body: {
      foo: 'bar'
    },
    headers: {
      'content-type': 'application/xml'
    }
  });

  const res = await NextRestFramework(config).defineRoute({
    POST: {
      input: {
        contentType: 'application/json',
        body: z.string()
      },
      output: [],
      handler: () => {}
    }
  })(req, context);

  const json = await res?.json();
  expect(res?.status).toEqual(415);

  expect(json).toEqual({
    message: DEFAULT_ERRORS.invalidMediaType
  });
});

it.each([
  {
    definedContentType: 'application/json',
    requestContentType: 'application/json'
  },
  {
    definedContentType: 'application/json',
    requestContentType: 'application/json; charset=utf-8'
  },
  {
    definedContentType: 'application/form-data',
    requestContentType: 'application/form-data; name: "foo"'
  }
])(
  'works with different content types: %s',
  async ({ definedContentType, requestContentType }) => {
    const { req, context } = createNextRestFrameworkMocks({
      method: ValidMethod.POST,
      body: {
        foo: 'bar'
      },
      headers: {
        'content-type': requestContentType
      }
    });

    const res = await NextRestFramework(config).defineRoute({
      POST: {
        input: {
          contentType: definedContentType,
          body: z.object({
            foo: z.string()
          })
        },
        output: [
          {
            status: 201,
            contentType: 'application/json',
            schema: z.object({
              foo: z.string()
            })
          }
        ],
        handler: () => NextResponse.json({ foo: 'bar' })
      }
    })(req, context);

    const json = await res?.json();
    expect(res?.status).toEqual(200);
    expect(json).toEqual({ foo: 'bar' });
  }
);

it('returns a default error response', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET
  });

  console.error = jest.fn();

  const res = await NextRestFramework(config).defineRoute({
    GET: {
      output: [],
      handler: () => {
        throw Error('Something went wrong');
      }
    }
  })(req, context);

  const json = await res?.json();

  expect(json).toEqual({
    message: DEFAULT_ERRORS.unexpectedError
  });
});

it('works with an error handler', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET
  });

  console.log = jest.fn();

  const res = await NextRestFramework({
    ...config,
    errorHandler: () => {
      console.log('foo');
      return NextResponse.json({ message: 'foo' }, { status: 500 });
    }
  }).defineRoute({
    GET: {
      output: [],
      handler: () => {
        throw Error('Something went wrong');
      }
    }
  })(req, context);

  const json = await res?.json();
  expect(console.log).toBeCalledWith('foo');
  expect(res?.status).toEqual(500);

  expect(json).toEqual({
    message: 'foo'
  });
});

it('suppresses errors in production mode by default', async () => {
  const { req, context } = createNextRestFrameworkMocks({
    method: ValidMethod.GET
  });

  console.error = jest.fn();
  process.env = { ...process.env, NODE_ENV: 'production' };

  await NextRestFramework(config).defineRoute({
    GET: {
      output: [],
      handler: () => {
        throw Error('Something went wrong');
      }
    }
  })(req, context);

  expect(console.error).toBeCalledWith(
    chalk.red(
      'Next REST Framework encountered an error - suppressed in production mode.'
    )
  );
});
